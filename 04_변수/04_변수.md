# [04장] 변수

**메모리와 변수**

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용하여 데이터를 기억한다.

```jsx
// result1 변수 선언, 자바스크립트의 원시타입인 undefined가 암묵적으로 할당되어 초기화됨
var result1;

// result2 변수 선언, 값을 할당(대입, 저장)
var result2 = 10 + 20; // 피연산자: 10, 20 / 연산자: + / 변수: result

// result2 변수 값 참조(읽기)
console.log(result2);

// 선언하지 않은 식별자 참조 시, 참조 에러 발생
console.log(result3); // ReferenceError: result3 is not defined
```

- 메모리: 데이터를 저장할 수 있는 메모리 셀의 집합체. 셀 하나의 크기는 1바이트(8비트). 각 고유의 메모리 주소를 가진다. 변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장도 값을 반환한다.
  - 예) 4GB 메모리는 0~ 4,294,967,295(0x00000000 ~ 0xFFFFFFFF)까지의 메모리 주소를 가짐.
- 변수: 값의 위치를 가리키는 이름. 즉 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인 이름. 식별할 수 있는 고유한 값이라 해서 ‘식별자' 라고도 부름. 모든 식별자는 실행 컨텍스트에 등록됨.
- 실행 컨텍스트: 자바스크립트 엔진이 소스코드를 평가하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다. 변수 이름과 값은 키, 값 형식인 객체로 등록되어 관리된다.

**변수 선언 실행 시점과 변수 호이스팅**

```jsx
console.log(score); // 변수 참조 시, undefined 반환

var score; // 변수 선언문
```

변수 선언문보다 참조하는 코드가 앞에 있다. 순차적으로 실행되기 때문에 참조 에러가 발생할 것 같지만, undefined가 출력된다. 그 이유는 **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라, 그 이전 단계에서 먼저 실행되기 때문**이다. 따라서 변수 선언이 어디 위치하는가에 상관없이 어디서든지 변수를 참조할 수 있다. 이를 변수 호이스팅이라고 한다.

- 실행 시점에 대한 구체적인 추가 설명: 자바스크립트 엔진은 순차적으로 소스코드를 실행하기에 앞서, 먼저 소스코드의 평가 과정을 거치면서 실행 준비를 한다. 이 때 자바스크립트 엔진은 변수 선언, 함수 선언문 등 모든 선언문을 소스코드에서 찾아서 먼저 실행한다. 그 후 모든 선언문을 제외하고 순차적으로 실행한다.
- 변수 호이스팅: 변수 선언문이 선두로 끌어올려진 것처럼 동작하는 자바스크립트의 특징

**변수 할당 시점**

```jsx
console.log(score); // 변수 참조 시, undefined 반환

var score; // 변수 선언문
score = 80; // 변수 할당

console.log(score); // 변수 참조 시, 80 반환
```

**변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, 변수 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**
주의) 이렇게 변수에 값을 할당할 경우, 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당된 80을 저장한다.

**변수 재할당**

- var, let: 변수에 재할당 가능
- const: 변수에 재할당 불가능, 상수 표현 가능

```jsx
var score; // 변수 선언문, undefined 할당. 예시 주소: 0x000000F2
score = 80; // 변수 할당. 예시 주소: 0x00001332
score = 90; // 변수 재할당. 예시 주소: 0x0569F913
```

score 변수의 이전 값인 undefined와 80은 어떤 변수도 값으로 갖고 있지 않다, 즉 어떤 식별자와도 연결되어 있지 않다. 이런 불필요한 값들은 가비지 콜렉터에 의해 매모리에서 자동 해제된다. 단, 메모리에서 언제 해제될지는 예측할 수 없다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서, 가비지 콜렉터를 통해 메모리 누수를 방지한다.

- 가비지 콜렉터: 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능이다.
- 더 이상 사용되지 않는 메모리: 어떤 식별자도 참조하지 않는 메모리 공간
- 프로그래밍 언어는 메모리 관리 방식에 따라 매니지드 언어, 언매니지드 언어로 분류할 수 있다.
  C언어: 언매니지드 언어로, 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc(), free() 같은 저수준 메모리 제어 기능 제공. 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만, 그 반대의 경우 치명적인 오류를 생산할 가능성 있음.
  JS: 매니지드 언어로, 언어 차원에서 메모리 관리 기능을 담당하고 개발아의 메모리 제어를 허용하지 않는다. 어느 정도 일정한 생산성을 확보할 수 있다는 장점이 있지만, 성능 면에서 어느 정도 손실은 감수할 수밖에 없다.

- 식별자: 값을 식별할 수 있는 고유한 이름, 네이밍 규칙 준수
- 네이밍 규칙: 특수문자 제외한 문자, 숫자, 언더스코어(\_), 달러기호 포함 가능
  단, 숫자로 시작하는 것, 예약어는 허용하지 않음

```jsx
// 예약어
await, break, case, catch, class, const,
continue, debugger, default, delete, do, else,
enum, export, extends, false, finally, for,
Function, if, implements*, import, in, instaseof,
interfase*, let*, new, null, package*, private*,
this, throw, true, try, typeof, var,
void, while, with, yield*

// * 식별자로 사용 가능하나 strict mode에서는 사용 불가
```

- 네이밍 컨벤션: 하나 이상의 영어 단어로 구성된 식별자를 만들 때, 가독성 좋게 단어를 한눈에 파악하기 위해 규정한 명명 규칙.

```jsx
let firstName; // 카멜 케이스 (camelCase)

let first_name; // 스네이크 케이스 (snake_case)

let FirstName; // 파스칼 케이스 (PascalCase)

// 헝가리언 케이스 (typeHungarianCase)
let strFirstNamel; // type + identifier
let $elem = document.getElementById('myId'); // DOM node
let obervable$ = fromEvent(document, 'click'); // RxJS Observable
```

일반적으로 변수나 함수 이름에는 카멜 케이스, 생성자 함수나 클래스 이름에는 파스칼 케이스 사용. ECMAScript에 정의된 객체나 함수들도 카멜, 파스칼 케이스를 사용하고 있기에, 코드 전체의 가독성을 높이기 위해서 카멜, 파스칼 케이스를 따르는 것이 유리하다.
